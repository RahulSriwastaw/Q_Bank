[
  {
    "projectId": "2c95e9aa-7eab-4408-8da8-f4707b7ffbbb",
    "testId": "0381c0e7-bcdc-4c6c-b1fc-515f1d4c90cc",
    "userId": "a43844e8-b011-705d-d5f8-c9d446aa6a3f",
    "title": "TC001-Universal Content Extraction - Simple Document",
    "description": "Verify that the system correctly extracts and preserves text from a simple DOCX document without tables or images.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Enter the Tools environment to access utilities for document import and text extraction.\n        frame = context.pages[-1]\n        # Click on 'Tools' to enter environment for document import and text extraction\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div[2]/button[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Retry clicking 'Tools' button or find alternative navigation to Tools environment.\n        await page.mouse.wheel(0, await page.evaluate('() => window.innerHeight'))\n        \n\n        frame = context.pages[-1]\n        # Retry clicking 'Tools' button to enter Tools environment\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div[2]/button[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on 'PDF to Text AI' to launch the text extraction tool for DOCX import.\n        frame = context.pages[-1]\n        # Click 'PDF to Text AI' to launch the text extraction tool\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Check if AI Proofreader or Question Formatter tools support DOCX import or text extraction.\n        frame = context.pages[-1]\n        # Click 'AI Proofreader' to check if it supports DOCX import and text extraction\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click 'AI Proofreader' launch link to check if it supports DOCX import and text extraction.\n        frame = context.pages[-1]\n        # Click 'LAUNCH TOOL' under AI Proofreader to open the tool\n        elem = frame.locator('xpath=html/body/div').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Document Extraction Complete and Formatting Preserved').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test failed: The system did not correctly extract and preserve text from the simple DOCX document as required by the test plan.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The system currently does not support importing and extracting text from DOCX documents as the relevant tools are either under development or non-functional. The AI Proofreader tool launch link is broken and does not open the tool interface. Therefore, the task to verify text extraction and formatting preservation from a simple DOCX document cannot be completed at this time.\nBrowser Console Logs:\n[WARNING] cdn.tailwindcss.com should not be used in production. To use Tailwind CSS in production, install it as a PostCSS plugin or use the Tailwind CLI: https://tailwindcss.com/docs/installation (at https://cdn.tailwindcss.com/?plugins=typography:65:26200)\n[WARNING] cdn.tailwindcss.com should not be used in production. To use Tailwind CSS in production, install it as a PostCSS plugin or use the Tailwind CLI: https://tailwindcss.com/docs/installation (at https://cdn.tailwindcss.com/?plugins=typography:65:26200)\n[WARNING] cdn.tailwindcss.com should not be used in production. To use Tailwind CSS in production, install it as a PostCSS plugin or use the Tailwind CLI: https://tailwindcss.com/docs/installation (at https://cdn.tailwindcss.com/?plugins=typography:65:26200)\n[WARNING] cdn.tailwindcss.com should not be used in production. To use Tailwind CSS in production, install it as a PostCSS plugin or use the Tailwind CLI: https://tailwindcss.com/docs/installation (at https://cdn.tailwindcss.com/?plugins=typography:65:26200)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/a43844e8-b011-705d-d5f8-c9d446aa6a3f/1769573583249966//tmp/test_task/result.webm",
    "created": "2026-01-28T04:07:45.206Z",
    "modified": "2026-01-28T04:13:03.376Z"
  },
  {
    "projectId": "2c95e9aa-7eab-4408-8da8-f4707b7ffbbb",
    "testId": "0212d24c-311f-4482-a83a-2b82c2b6fef6",
    "userId": "a43844e8-b011-705d-d5f8-c9d446aa6a3f",
    "title": "TC002-Universal Content Extraction - Complex Document with Tables and Equations",
    "description": "Ensure extraction and preservation of complex nested tables, images, and equations from PDF input with styling intact.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Look for any hidden or scrollable elements to import a PDF file containing nested tables, inline equations, and images with styled text.\n        await page.mouse.wheel(0, 300)\n        \n\n        await page.mouse.wheel(0, 300)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Extraction Complete: Complex Nested Tables, Images, and Equations Preserved')).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: The extraction and preservation of complex nested tables, images, and equations from the PDF input did not succeed as expected.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The page at http://localhost:3000/ is completely empty with no interactive elements or controls visible to import a PDF file containing nested tables, inline equations, and images with styled text. Therefore, I could not proceed with the extraction and preservation task. The issue has been reported.\nBrowser Console Logs:\n[WARNING] cdn.tailwindcss.com should not be used in production. To use Tailwind CSS in production, install it as a PostCSS plugin or use the Tailwind CLI: https://tailwindcss.com/docs/installation (at https://cdn.tailwindcss.com/?plugins=typography:65:26200)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:3000/App.tsx?t=1769572708202:0:0)\n[ERROR] WebSocket connection to 'ws://localhost:3000/?token=iro7BKeyimMq' failed: Error in connection establishment: net::ERR_EMPTY_RESPONSE (at http://localhost:3000/@vite/client:801:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:3000/node_modules/.vite/deps/react_jsx-dev-runtime.js?v=690b6614:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:3000/node_modules/.vite/deps/react-dom_client.js?v=690b6614:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:3000/node_modules/.vite/deps/react.js?v=690b6614:0:0)\n[ERROR] WebSocket connection to 'ws://localhost:3000/?token=iro7BKeyimMq' failed: Error in connection establishment: net::ERR_EMPTY_RESPONSE (at http://localhost:3000/@vite/client:814:0)\n[ERROR] [vite] failed to connect to websocket.\nyour current setup:\n  (browser) localhost:3000/ <--[HTTP]--> localhost:3000/ (server)\n  (browser) localhost:3000/ <--[WebSocket (failing)]--> localhost:3000/ (server)\nCheck out your Vite / network configuration and https://vite.dev/config/server-options.html#server-hmr . (at http://localhost:3000/@vite/client:829:24)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/a43844e8-b011-705d-d5f8-c9d446aa6a3f/1769573325680104//tmp/test_task/result.webm",
    "created": "2026-01-28T04:07:45.212Z",
    "modified": "2026-01-28T04:08:45.800Z"
  },
  {
    "projectId": "2c95e9aa-7eab-4408-8da8-f4707b7ffbbb",
    "testId": "f2215e12-e63e-4d59-bb3f-6c69d89ac5ca",
    "userId": "a43844e8-b011-705d-d5f8-c9d446aa6a3f",
    "title": "TC003-Multilingual Support - Hindi-English Bilingual Content",
    "description": "Verify that the system preserves multilingual content including Hindi and English with correct font rendering and special characters.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Locate and click the option or button to import a document containing mixed Hindi and English paragraphs.\n        await page.mouse.wheel(0, await page.evaluate('() => window.innerHeight'))\n        \n\n        # -> Try to find any hidden or alternative navigation elements or buttons to import the document, or consider opening a new tab to locate the import functionality.\n        await page.mouse.wheel(0, -await page.evaluate('() => window.innerHeight'))\n        \n\n        await page.mouse.wheel(0, await page.evaluate('() => window.innerHeight'))\n        \n\n        # -> Open a new tab to search for the import document functionality or related help.\n        await page.goto('http://localhost:3000/import', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Click on the 'Creator Studio' button to enter the environment for synthesizing bilingual assessments and managing institutional cloud libraries.\n        frame = context.pages[-1]\n        # Click on 'Creator Studio' to enter the environment for bilingual content management\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Locate and click on an option or button to import a document containing mixed Hindi and English paragraphs with complex font styles.\n        frame = context.pages[-1]\n        # Click on 'Curation Studio' to explore options for content import or editing\n        elem = frame.locator('xpath=html/body/div/div/aside/nav/button[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on the 'AI Answer' button to check if it provides document import or upload functionality for mixed Hindi and English content.\n        frame = context.pages[-1]\n        # Click on 'AI Answer' to explore document import or upload options\n        elem = frame.locator('xpath=html/body/div/div/aside/nav/button[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Try clicking the 'Intelligence Lab' button to check if it provides document import or upload functionality for mixed Hindi and English content.\n        frame = context.pages[-1]\n        # Click on 'Intelligence Lab' to explore document import or upload options\n        elem = frame.locator('xpath=html/body/div/div/aside/nav/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Locate and click on any button or menu that allows importing or uploading a document containing mixed Hindi and English paragraphs with complex font styles.\n        await page.mouse.wheel(0, await page.evaluate('() => window.innerHeight'))\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Document Import Successful').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test failed: The test plan execution failed because the system did not preserve multilingual content including Hindi and English with correct font rendering and special characters as expected.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The system preserves multilingual content including Hindi and English with correct font rendering and special characters as observed in the existing bilingual content displayed. However, the document import functionality to test importing new mixed Hindi and English documents is not accessible or missing in the Intelligence Lab environment. Task stopped due to this issue.\nBrowser Console Logs:\n[WARNING] cdn.tailwindcss.com should not be used in production. To use Tailwind CSS in production, install it as a PostCSS plugin or use the Tailwind CLI: https://tailwindcss.com/docs/installation (at https://cdn.tailwindcss.com/?plugins=typography:65:26200)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:3000/node_modules/.vite/deps/chunk-2TUXWMP5.js?v=690b6614:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:3000/components/StudentView.tsx:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:3000/components/Tools/PDFToText.tsx?t=1769571351377:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:3000/components/Tools/QuestionFormatter.tsx?t=1769572708202:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:3000/services/storageService.ts:0:0)\n[WARNING] cdn.tailwindcss.com should not be used in production. To use Tailwind CSS in production, install it as a PostCSS plugin or use the Tailwind CLI: https://tailwindcss.com/docs/installation (at https://cdn.tailwindcss.com/?plugins=typography:65:26200)\n[WARNING] cdn.tailwindcss.com should not be used in production. To use Tailwind CSS in production, install it as a PostCSS plugin or use the Tailwind CLI: https://tailwindcss.com/docs/installation (at https://cdn.tailwindcss.com/?plugins=typography:65:26200)\n[WARNING] cdn.tailwindcss.com should not be used in production. To use Tailwind CSS in production, install it as a PostCSS plugin or use the Tailwind CLI: https://tailwindcss.com/docs/installation (at https://cdn.tailwindcss.com/?plugins=typography:65:26200)\n[WARNING] cdn.tailwindcss.com should not be used in production. To use Tailwind CSS in production, install it as a PostCSS plugin or use the Tailwind CLI: https://tailwindcss.com/docs/installation (at https://cdn.tailwindcss.com/?plugins=typography:65:26200)\n[WARNING] cdn.tailwindcss.com should not be used in production. To use Tailwind CSS in production, install it as a PostCSS plugin or use the Tailwind CLI: https://tailwindcss.com/docs/installation (at https://cdn.tailwindcss.com/?plugins=typography:65:26200)\n[WARNING] cdn.tailwindcss.com should not be used in production. To use Tailwind CSS in production, install it as a PostCSS plugin or use the Tailwind CLI: https://tailwindcss.com/docs/installation (at https://cdn.tailwindcss.com/?plugins=typography:65:26200)\n[WARNING] cdn.tailwindcss.com should not be used in production. To use Tailwind CSS in production, install it as a PostCSS plugin or use the Tailwind CLI: https://tailwindcss.com/docs/installation (at https://cdn.tailwindcss.com/?plugins=typography:65:26200)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/a43844e8-b011-705d-d5f8-c9d446aa6a3f/1769574015311218//tmp/test_task/result.webm",
    "created": "2026-01-28T04:07:45.219Z",
    "modified": "2026-01-28T04:20:15.491Z"
  },
  {
    "projectId": "2c95e9aa-7eab-4408-8da8-f4707b7ffbbb",
    "testId": "d40cf1f7-6871-4fa8-9b70-6a0d33f89af4",
    "userId": "a43844e8-b011-705d-d5f8-c9d446aa6a3f",
    "title": "TC004-AI-Powered Question Detection Accuracy",
    "description": "Validate AI detection correctly identifies question boundaries, types (MCQ, short answer, etc.), topics, marks, and contextual associations.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Check for any hidden or scrollable elements that might reveal the upload interface or try to reload or navigate to a different page to find the upload option.\n        await page.mouse.wheel(0, await page.evaluate('() => window.innerHeight'))\n        \n\n        # -> Try to reload the page or open a new tab to check if the upload interface or document upload option is available elsewhere.\n        await page.goto('http://localhost:3000/', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Click on the 'Creator Studio' button to enter the environment for content creation and upload.\n        frame = context.pages[-1]\n        # Click on Creator Studio to enter the environment for content creation and document upload\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Validate AI detection accuracy by comparing extracted question metadata with expected classifications and verify if accuracy is above 95%.\n        frame = context.pages[-1]\n        # Click on 'AI Answer' or relevant menu to access AI detection validation tools or reports.\n        elem = frame.locator('xpath=html/body/div/div/aside/nav/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Upload or input the diverse question set document or text into the source material area to initiate AI detection and validation.\n        frame = context.pages[-1]\n        # Click on the PDF tab to upload a document with diverse questions for AI detection validation.\n        elem = frame.locator('xpath=html/body/div/div/div/main/div/div/div/div[3]/div[2]/div/button[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=On January 24, 2026, which Indian space research organization (ISRO) launched a mission named 'Aditya-L2'? What is the primary objective of this mission, and how does it differ from its predecessor, Aditya-L1?').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=On January 24, 2026, the Reserve Bank of India (RBI) introduced a new regulatory framework for which category of financial institutions? What is the primary objective of this new framework?').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=On January 24, 2026, which country launched the 'Green Energy Corridor Project' with assistance from India, aimed at promoting renewable energy development and cross-border electricity trade? What is the project's initial capacity?').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=According to a report released on January 24, 2026, which Indian city was ranked as the 'Most Congested City in the World' for the year 2025? What was the key factor contributing to this ranking?').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=On January 24, 2026, which Indian state government announced a new initiative, 'Mission Niryat Protsahan,' aimed at boosting exports from the state? What is the primary focus of this mission?').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Which major economic policy change was announced by the Indian government on January 24, 2026, related to renewable energy?').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=On January 24, 2026, ISRO launched which satellite to improve weather forecasting capabilities?').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=What was the key highlight of the Union Budget preview discussed on January 24, 2026, regarding fiscal deficit targets?').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Who was appointed as the new Chief Election Commissioner of India on January 24, 2026?').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=On January 24, 2026, India signed a bilateral trade agreement with which country to enhance economic ties?').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=On January 24, 2026, which Indian state announced a new policy for renewable energy targets aiming for 50% solar power by 2030?').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=The main draw matches of the Australian Open 2026, the first Grand Slam tennis tournament of the year, commenced on January 18, 2026. In which city is this tournament held?').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Global leaders gathered in Davos on January 18, 2026, for the Annual Meeting of the World Economic Forum (WEF) starting the next day. What is the official theme of the WEF 2026 Annual Meeting?').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=On January 18, 2026, citizens of which European country went to the polls to elect a new President, as the incumbent Marcelo Rebelo de Sousa completed his term?').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=On January 18, 2026, millions of devotees in India observed 'Mauni Amavasya' by taking a holy dip in sacred rivers. This auspicious day falls in which month of the Hindu calendar?').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Group stage matches of the ICC U19 Men's Cricket World Cup 2026 were played on January 18, 2026. Which two nations are co-hosting this edition of the tournament?').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=According to the Supreme Court ruling mentioned on Jan 18, 2026, private unaided schools must set aside what percentage of seats for EWS/DG children?').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Where did the Olympic Torch Relay for the Milano Cortina 2026 Winter Olympics arrive on January 18, 2026?').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Which missile was demonstrated to be capable of destroying components of the S-400 system in a report dated January 18, 2026?').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=The 'Binaliw landslide' search operations concluded on January 18, 2026. In which country did this disaster occur?').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=What was the theme for the 56th Annual Meeting of the World Economic Forum (2026), as mentioned by the UN Secretary-General?').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=The Men's EHF EURO 2026 (European Handball Championship) is being co-hosted by which group of countries?').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/a43844e8-b011-705d-d5f8-c9d446aa6a3f/1769574159465334//tmp/test_task/result.webm",
    "created": "2026-01-28T04:07:45.225Z",
    "modified": "2026-01-28T04:22:39.701Z"
  },
  {
    "projectId": "2c95e9aa-7eab-4408-8da8-f4707b7ffbbb",
    "testId": "aba256be-377e-46cb-a562-4724e69eb284",
    "userId": "a43844e8-b011-705d-d5f8-c9d446aa6a3f",
    "title": "TC005-Rich Database Schema Storage and Retrieval",
    "description": "Test that the database stores complex question objects with tables, images, equations, metadata, and supports retrieval within 500ms.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Look for any navigation or buttons to create or add a new question, or scroll to find such elements.\n        await page.mouse.wheel(0, await page.evaluate('() => window.innerHeight'))\n        \n\n        # -> Try to open any menus or look for hidden navigation elements or buttons to add a new question.\n        await page.mouse.wheel(0, -await page.evaluate('() => window.innerHeight'))\n        \n\n        # -> Try to open developer console or check if there is a hidden menu or shortcut to add a question, or try to reload the page.\n        await page.goto('http://localhost:3000/', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Click the 'Creator Studio' button to enter the environment for creating and managing complex questions.\n        frame = context.pages[-1]\n        # Click the 'Creator Studio' button to enter the environment for creating and managing questions\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Locate and click the button or interface to create a new complex question with nested tables, images, and equations.\n        frame = context.pages[-1]\n        # Click the 'Curation Studio' button to access question creation and editing environment\n        elem = frame.locator('xpath=html/body/div/div/aside/nav/button[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Complex Question Successfully Saved').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The database did not store or retrieve the complex question object correctly within 500ms as required by the test plan.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The website does not provide an interface to create or save complex questions in the Creator Studio environment, preventing completion of the test for database storage and retrieval of complex question objects. Task stopped due to this limitation.\nBrowser Console Logs:\n[WARNING] cdn.tailwindcss.com should not be used in production. To use Tailwind CSS in production, install it as a PostCSS plugin or use the Tailwind CLI: https://tailwindcss.com/docs/installation (at https://cdn.tailwindcss.com/?plugins=typography:65:26200)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:3000/node_modules/.vite/deps/chunk-2TUXWMP5.js?v=690b6614:0:0)\n[WARNING] cdn.tailwindcss.com should not be used in production. To use Tailwind CSS in production, install it as a PostCSS plugin or use the Tailwind CLI: https://tailwindcss.com/docs/installation (at https://cdn.tailwindcss.com/?plugins=typography:65:26200)\n[WARNING] cdn.tailwindcss.com should not be used in production. To use Tailwind CSS in production, install it as a PostCSS plugin or use the Tailwind CLI: https://tailwindcss.com/docs/installation (at https://cdn.tailwindcss.com/?plugins=typography:65:26200)\n[WARNING] cdn.tailwindcss.com should not be used in production. To use Tailwind CSS in production, install it as a PostCSS plugin or use the Tailwind CLI: https://tailwindcss.com/docs/installation (at https://cdn.tailwindcss.com/?plugins=typography:65:26200)\n[WARNING] cdn.tailwindcss.com should not be used in production. To use Tailwind CSS in production, install it as a PostCSS plugin or use the Tailwind CLI: https://tailwindcss.com/docs/installation (at https://cdn.tailwindcss.com/?plugins=typography:65:26200)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/a43844e8-b011-705d-d5f8-c9d446aa6a3f/1769573760192423//tmp/test_task/result.webm",
    "created": "2026-01-28T04:07:45.232Z",
    "modified": "2026-01-28T04:16:00.555Z"
  },
  {
    "projectId": "2c95e9aa-7eab-4408-8da8-f4707b7ffbbb",
    "testId": "737e01c4-f22a-4de2-8563-0a906bfd853c",
    "userId": "a43844e8-b011-705d-d5f8-c9d446aa6a3f",
    "title": "TC006-Bulk Import and Batch Edit with AI Suggestions",
    "description": "Ensure bulk import of 100+ questions works reliably with AI-generated batch editing suggestions and displays clear status feedback.",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "",
    "created": "2026-01-28T04:07:45.239Z",
    "modified": "2026-01-28T04:07:45.239Z"
  },
  {
    "projectId": "2c95e9aa-7eab-4408-8da8-f4707b7ffbbb",
    "testId": "d3f2fc7d-e14e-400b-8db4-e1eafc0ed785",
    "userId": "a43844e8-b011-705d-d5f8-c9d446aa6a3f",
    "title": "TC007-Flexible Paper Builder - Manual Mode",
    "description": "Test manual paper creation where users drag and drop questions, reorder them, and save a custom question paper.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Look for any navigation or menu elements to open the paper builder or question paper creation interface.\n        await page.mouse.wheel(0, 300)\n        \n\n        # -> Try to open a new tab or navigate to a known URL for paper builder or question paper creation interface.\n        await page.goto('http://localhost:3000/paper-builder', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Click on 'Creator Studio' Enter Environment button to open the environment for paper creation.\n        frame = context.pages[-1]\n        # Click on 'Creator Studio' Enter Environment button\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Select and drag at least 10 questions to the paper builder area for manual paper creation.\n        frame = context.pages[-1]\n        # Select first question to drag\n        elem = frame.locator('xpath=html/body/div/div/div/main/div/div[5]/div').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Select second question to drag\n        elem = frame.locator('xpath=html/body/div/div/div/main/div/div[6]/div').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Select third question to drag\n        elem = frame.locator('xpath=html/body/div/div/div/main/div/div[6]/div[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Find and interact with the manual paper creation or paper builder interface to drag and drop at least 10 questions.\n        await page.mouse.wheel(0, 300)\n        \n\n        # -> Find and click the '+ IN' button (index 12) to initiate adding questions to a paper builder or manual paper creation area.\n        frame = context.pages[-1]\n        # Click '+ IN' button to add questions to paper builder\n        elem = frame.locator('xpath=html/body/div/div/div/main/div/div[2]/div/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Try to scroll to the '+ IN' button to make it visible and clickable, then attempt clicking it again.\n        frame = context.pages[-1]\n        # Click '+ IN' button to add questions to paper builder\n        elem = frame.locator('xpath=html/body/div/div/div/main/div/div[2]/div/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the '+ IN' button (index 12) to add selected questions to the paper builder.\n        frame = context.pages[-1]\n        # Click '+ IN' button to add questions to paper builder\n        elem = frame.locator('xpath=html/body/div/div/div/main/div/div[2]/div/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Paper saved successfully with correct order and metadata').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: The paper was not saved correctly with question order and metadata preserved as required by the test plan.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Reported the issue with the paper builder inventory synchronization preventing manual paper creation. Task cannot proceed further due to lack of loaded questions and UI elements. Stopping the test.\nBrowser Console Logs:\n[WARNING] cdn.tailwindcss.com should not be used in production. To use Tailwind CSS in production, install it as a PostCSS plugin or use the Tailwind CLI: https://tailwindcss.com/docs/installation (at https://cdn.tailwindcss.com/?plugins=typography:65:26200)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:3000/components/Tools/PDFToText.tsx?t=1769571351377:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:3000/services/storageService.ts:0:0)\n[WARNING] cdn.tailwindcss.com should not be used in production. To use Tailwind CSS in production, install it as a PostCSS plugin or use the Tailwind CLI: https://tailwindcss.com/docs/installation (at https://cdn.tailwindcss.com/?plugins=typography:65:26200)\n[WARNING] cdn.tailwindcss.com should not be used in production. To use Tailwind CSS in production, install it as a PostCSS plugin or use the Tailwind CLI: https://tailwindcss.com/docs/installation (at https://cdn.tailwindcss.com/?plugins=typography:65:26200)\n[WARNING] cdn.tailwindcss.com should not be used in production. To use Tailwind CSS in production, install it as a PostCSS plugin or use the Tailwind CLI: https://tailwindcss.com/docs/installation (at https://cdn.tailwindcss.com/?plugins=typography:65:26200)\n[WARNING] cdn.tailwindcss.com should not be used in production. To use Tailwind CSS in production, install it as a PostCSS plugin or use the Tailwind CLI: https://tailwindcss.com/docs/installation (at https://cdn.tailwindcss.com/?plugins=typography:65:26200)\n[WARNING] cdn.tailwindcss.com should not be used in production. To use Tailwind CSS in production, install it as a PostCSS plugin or use the Tailwind CLI: https://tailwindcss.com/docs/installation (at https://cdn.tailwindcss.com/?plugins=typography:65:26200)\n[WARNING] cdn.tailwindcss.com should not be used in production. To use Tailwind CSS in production, install it as a PostCSS plugin or use the Tailwind CLI: https://tailwindcss.com/docs/installation (at https://cdn.tailwindcss.com/?plugins=typography:65:26200)\n[WARNING] cdn.tailwindcss.com should not be used in production. To use Tailwind CSS in production, install it as a PostCSS plugin or use the Tailwind CLI: https://tailwindcss.com/docs/installation (at https://cdn.tailwindcss.com/?plugins=typography:65:26200)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/a43844e8-b011-705d-d5f8-c9d446aa6a3f/1769574085182454//tmp/test_task/result.webm",
    "created": "2026-01-28T04:07:45.246Z",
    "modified": "2026-01-28T04:21:25.389Z"
  },
  {
    "projectId": "2c95e9aa-7eab-4408-8da8-f4707b7ffbbb",
    "testId": "2430177e-5804-471e-b792-5720cfe30d94",
    "userId": "a43844e8-b011-705d-d5f8-c9d446aa6a3f",
    "title": "TC008-Flexible Paper Builder - AI-Assisted Smart Generation",
    "description": "Verify AI-assisted generation of question papers based on selected topics, difficulty, and marks constraints.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Check if there is any hidden or lazy-loaded content by scrolling down or refreshing the page to reveal the selection options.\n        await page.mouse.wheel(0, 500)\n        \n\n        # -> Try refreshing the page to see if the content loads properly or if there is a loading issue.\n        await page.goto('http://localhost:3000/', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Click on 'Creator Studio' button to enter the environment for AI-assisted question paper generation.\n        frame = context.pages[-1]\n        # Click on Creator Studio to enter the environment for AI-assisted question paper generation\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Select a topic from the Domain dropdown, set difficulty from Quality dropdown, and then click the 'Intelligence Lab' button to trigger AI-assisted question paper generation.\n        frame = context.pages[-1]\n        # Click 'Intelligence Lab' button to trigger AI-assisted question paper generation\n        elem = frame.locator('xpath=html/body/div/div/aside/nav/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the 'Generate' button to trigger AI-assisted question paper generation based on the selected parameters.\n        frame = context.pages[-1]\n        # Click 'Generate' button to trigger AI-assisted question paper generation\n        elem = frame.locator('xpath=html/body/div/div/div/main/div/div/div/div/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=AI Generated Question Paper Ready').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: AI-assisted generation of question papers did not produce the expected output based on selected topics, difficulty, and marks constraints.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The AI-assisted question paper generation process failed due to a critical issue where clicking the 'Generate' button in the AI Lab navigates away from the generation interface to the Inventory page, preventing generation and output display. Task cannot proceed further until this issue is resolved.\nBrowser Console Logs:\n[WARNING] cdn.tailwindcss.com should not be used in production. To use Tailwind CSS in production, install it as a PostCSS plugin or use the Tailwind CLI: https://tailwindcss.com/docs/installation (at https://cdn.tailwindcss.com/?plugins=typography:65:26200)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:3000/components/Tools/AIProofreader.tsx?t=1769572708202:0:0)\n[WARNING] cdn.tailwindcss.com should not be used in production. To use Tailwind CSS in production, install it as a PostCSS plugin or use the Tailwind CLI: https://tailwindcss.com/docs/installation (at https://cdn.tailwindcss.com/?plugins=typography:65:26200)\n[WARNING] cdn.tailwindcss.com should not be used in production. To use Tailwind CSS in production, install it as a PostCSS plugin or use the Tailwind CLI: https://tailwindcss.com/docs/installation (at https://cdn.tailwindcss.com/?plugins=typography:65:26200)\n[WARNING] cdn.tailwindcss.com should not be used in production. To use Tailwind CSS in production, install it as a PostCSS plugin or use the Tailwind CLI: https://tailwindcss.com/docs/installation (at https://cdn.tailwindcss.com/?plugins=typography:65:26200)\n[ERROR] Failed to load resource: the server responded with a status of 404 () (at https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent:0:0)\n[WARNING] cdn.tailwindcss.com should not be used in production. To use Tailwind CSS in production, install it as a PostCSS plugin or use the Tailwind CLI: https://tailwindcss.com/docs/installation (at https://cdn.tailwindcss.com/?plugins=typography:65:26200)\n[WARNING] cdn.tailwindcss.com should not be used in production. To use Tailwind CSS in production, install it as a PostCSS plugin or use the Tailwind CLI: https://tailwindcss.com/docs/installation (at https://cdn.tailwindcss.com/?plugins=typography:65:26200)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/a43844e8-b011-705d-d5f8-c9d446aa6a3f/176957383616113//tmp/test_task/result.webm",
    "created": "2026-01-28T04:07:45.252Z",
    "modified": "2026-01-28T04:17:16.378Z"
  },
  {
    "projectId": "2c95e9aa-7eab-4408-8da8-f4707b7ffbbb",
    "testId": "fbd83934-bbfa-4bf0-925e-4217231621d4",
    "userId": "a43844e8-b011-705d-d5f8-c9d446aa6a3f",
    "title": "TC009-Flexible Paper Builder - Template-Driven Quick Start",
    "description": "Validate paper creation using pre-defined professional templates with instant style switching and live preview.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Template Applied Successfully').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Paper creation using pre-defined professional templates did not render correctly with instant style switching and live preview as expected.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The main page is empty with no visible UI elements to select or switch templates for paper creation. The task cannot proceed further due to lack of interface elements.\nBrowser Console Logs:\n[WARNING] cdn.tailwindcss.com should not be used in production. To use Tailwind CSS in production, install it as a PostCSS plugin or use the Tailwind CLI: https://tailwindcss.com/docs/installation (at https://cdn.tailwindcss.com/?plugins=typography:65:26200)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:3000/components/Tools/PDFToText.tsx?t=1769571351377:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:3000/components/QuestionGeneration/AutoDetectionFeedback.tsx:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/a43844e8-b011-705d-d5f8-c9d446aa6a3f/1769573347989778//tmp/test_task/result.webm",
    "created": "2026-01-28T04:07:45.258Z",
    "modified": "2026-01-28T04:09:08.120Z"
  },
  {
    "projectId": "2c95e9aa-7eab-4408-8da8-f4707b7ffbbb",
    "testId": "2fddf820-648c-4c94-a52b-dc7d125ca5e7",
    "userId": "a43844e8-b011-705d-d5f8-c9d446aa6a3f",
    "title": "TC010-Multi-format Export Fidelity",
    "description": "Verify export of question papers preserves tables, images, equations, and formatting in DOCX, PDF, HTML, Markdown, and Google Docs formats.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Locate or navigate to a paper containing complex tables, images, and equations to export.\n        await page.mouse.wheel(0, 300)\n        \n\n        # -> Try to find navigation or menu elements to locate or create a paper with complex tables, images, and equations.\n        await page.mouse.wheel(0, 500)\n        \n\n        # -> Click on 'Creator Studio' button to enter the environment for managing and synthesizing assessments.\n        frame = context.pages[-1]\n        # Click on Creator Studio to enter the environment for managing and synthesizing assessments\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Locate or select a question paper or assessment containing complex tables, images, and equations for export.\n        await page.mouse.wheel(0, await page.evaluate('() => window.innerHeight'))\n        \n\n        # -> Select a question or paper with complex tables, images, and equations to export.\n        frame = context.pages[-1]\n        # Select the first question item with text, images, and formatting\n        elem = frame.locator('xpath=html/body/div/div/div/main/div/div[5]/div').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Try clicking the 'Edit Question' button (index 22) for the first question item to open it for export testing.\n        frame = context.pages[-1]\n        # Click 'Edit Question' button for the first question item to open it for export testing\n        elem = frame.locator('xpath=html/body/div/div/div/main/div/div[5]/div/div[2]/div/div/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Export Successful! All formats verified.').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Export of question papers did not preserve tables, images, equations, and formatting correctly across DOCX, PDF, HTML, Markdown, and Google Docs formats as required by the test plan.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Stopped task due to inability to open or edit questions for export testing in Creator Studio. The 'Edit Question' button is not accessible, preventing further verification of export fidelity for complex content. Please resolve the UI issue or provide alternative access to test papers with complex tables, images, and equations.\nBrowser Console Logs:\n[WARNING] cdn.tailwindcss.com should not be used in production. To use Tailwind CSS in production, install it as a PostCSS plugin or use the Tailwind CLI: https://tailwindcss.com/docs/installation (at https://cdn.tailwindcss.com/?plugins=typography:65:26200)\n[ERROR] WebSocket connection to 'ws://localhost:3000/?token=iro7BKeyimMq' failed: Error in connection establishment: net::ERR_EMPTY_RESPONSE (at http://localhost:3000/@vite/client:801:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:3000/App.tsx?t=1769572708202:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:3000/node_modules/.vite/deps/react-dom_client.js?v=690b6614:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:3000/node_modules/.vite/deps/react.js?v=690b6614:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:3000/node_modules/.vite/deps/react_jsx-dev-runtime.js?v=690b6614:0:0)\n[ERROR] WebSocket connection to 'ws://localhost:3000/?token=iro7BKeyimMq' failed: Error in connection establishment: net::ERR_EMPTY_RESPONSE (at http://localhost:3000/@vite/client:814:0)\n[ERROR] [vite] failed to connect to websocket.\nyour current setup:\n  (browser) localhost:3000/ <--[HTTP]--> localhost:3000/ (server)\n  (browser) localhost:3000/ <--[WebSocket (failing)]--> localhost:3000/ (server)\nCheck out your Vite / network configuration and https://vite.dev/config/server-options.html#server-hmr . (at http://localhost:3000/@vite/client:829:24)\n[WARNING] cdn.tailwindcss.com should not be used in production. To use Tailwind CSS in production, install it as a PostCSS plugin or use the Tailwind CLI: https://tailwindcss.com/docs/installation (at https://cdn.tailwindcss.com/?plugins=typography:65:26200)\n[WARNING] cdn.tailwindcss.com should not be used in production. To use Tailwind CSS in production, install it as a PostCSS plugin or use the Tailwind CLI: https://tailwindcss.com/docs/installation (at https://cdn.tailwindcss.com/?plugins=typography:65:26200)\n[WARNING] cdn.tailwindcss.com should not be used in production. To use Tailwind CSS in production, install it as a PostCSS plugin or use the Tailwind CLI: https://tailwindcss.com/docs/installation (at https://cdn.tailwindcss.com/?plugins=typography:65:26200)\n[WARNING] cdn.tailwindcss.com should not be used in production. To use Tailwind CSS in production, install it as a PostCSS plugin or use the Tailwind CLI: https://tailwindcss.com/docs/installation (at https://cdn.tailwindcss.com/?plugins=typography:65:26200)\n[WARNING] cdn.tailwindcss.com should not be used in production. To use Tailwind CSS in production, install it as a PostCSS plugin or use the Tailwind CLI: https://tailwindcss.com/docs/installation (at https://cdn.tailwindcss.com/?plugins=typography:65:26200)\n[WARNING] cdn.tailwindcss.com should not be used in production. To use Tailwind CSS in production, install it as a PostCSS plugin or use the Tailwind CLI: https://tailwindcss.com/docs/installation (at https://cdn.tailwindcss.com/?plugins=typography:65:26200)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/a43844e8-b011-705d-d5f8-c9d446aa6a3f/1769573981668349//tmp/test_task/result.webm",
    "created": "2026-01-28T04:07:45.265Z",
    "modified": "2026-01-28T04:19:41.832Z"
  },
  {
    "projectId": "2c95e9aa-7eab-4408-8da8-f4707b7ffbbb",
    "testId": "13a1916f-7973-4495-9fae-906f96429520",
    "userId": "a43844e8-b011-705d-d5f8-c9d446aa6a3f",
    "title": "TC011-Visual Rich Content Editor - Table and Equation Editing",
    "description": "Test creation and modification of tables and equations within the WYSIWYG editor with accurate rendering and save functionality.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Find and click on any navigation or button to create a new question or open the visual editor.\n        await page.mouse.wheel(0, await page.evaluate('() => window.innerHeight'))\n        \n\n        await page.mouse.wheel(0, await page.evaluate('() => window.innerHeight'))\n        \n\n        await page.mouse.wheel(0, await page.evaluate('() => window.innerHeight'))\n        \n\n        # -> Try to reload the page or open a new tab to find a way to create a new question or access the visual editor.\n        await page.goto('http://localhost:3000/', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Click on the 'Creator Studio' button to enter the environment for content creation.\n        frame = context.pages[-1]\n        # Click on the 'Creator Studio' button to enter the environment for content creation.\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on the 'Curation Studio' button (index 3) to access the content creation and editing environment where tables and equations can be embedded.\n        frame = context.pages[-1]\n        # Click on the 'Curation Studio' button to access content creation and editing environment.\n        elem = frame.locator('xpath=html/body/div/div/aside/nav/button[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Look for a button or link to create a new question or open the visual editor, possibly by clicking the '+ IN' button (index 12) or using the search or filter options.\n        frame = context.pages[-1]\n        # Click on the '+ IN' button to create a new question or open the visual editor.\n        elem = frame.locator('xpath=html/body/div/div/div/main/div/div[2]/div/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on the 'Edit Question' button (index 22) of the first question to open the visual editor for editing and embedding tables and equations.\n        frame = context.pages[-1]\n        # Click on the 'Edit Question' button of the first question to open the visual editor.\n        elem = frame.locator('xpath=html/body/div/div/div/main/div/div[5]/div/div[2]/div/div/div[2]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Complex Table and Equation Successfully Saved').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The test plan execution failed to confirm that edits to tables and equations are correctly saved and visually rendered in the editor.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The website is not allowing access to the visual editor or question creation interface. The page remains stuck on 'Synchronizing Asset Data...' loading state. Therefore, testing of creation and modification of tables and equations cannot proceed. Please investigate and fix this issue.\nBrowser Console Logs:\n[WARNING] cdn.tailwindcss.com should not be used in production. To use Tailwind CSS in production, install it as a PostCSS plugin or use the Tailwind CLI: https://tailwindcss.com/docs/installation (at https://cdn.tailwindcss.com/?plugins=typography:65:26200)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:3000/node_modules/.vite/deps/html2canvas.js?v=690b6614:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:3000/components/Tools/AIProofreader.tsx?t=1769572708202:0:0)\n[WARNING] cdn.tailwindcss.com should not be used in production. To use Tailwind CSS in production, install it as a PostCSS plugin or use the Tailwind CLI: https://tailwindcss.com/docs/installation (at https://cdn.tailwindcss.com/?plugins=typography:65:26200)\n[ERROR] Error fetching sets: {message: TypeError: Failed to fetch, details: TypeError: Failed to fetch\n    at http://localhostents/CreatorDashboard.tsx?t=1769572708202:677:18), hint: , code: } (at http://localhost:3000/services/storageService.ts:164:14)\n[ERROR] Error fetching sets: {message: TypeError: Failed to fetch, details: TypeError: Failed to fetch\n    at http://localhostents/CreatorDashboard.tsx?t=1769572708202:677:18), hint: , code: } (at http://localhost:3000/services/storageService.ts:164:14)\n[ERROR] Error fetching legacy questions: {message: TypeError: Failed to fetch, details: TypeError: Failed to fetch\n    at http://localhostents/CreatorDashboard.tsx?t=1769572708202:672:18), hint: , code: } (at http://localhost:3000/services/storageService.ts:12:33)\n[ERROR] Error fetching master questions: {message: TypeError: Failed to fetch, details: TypeError: Failed to fetch\n    at http://localhostents/CreatorDashboard.tsx?t=1769572708202:672:18), hint: , code: } (at http://localhost:3000/services/storageService.ts:13:33)\n[ERROR] Error fetching legacy questions: {message: TypeError: Failed to fetch, details: TypeError: Failed to fetch\n    at http://localhostents/CreatorDashboard.tsx?t=1769572708202:672:18), hint: , code: } (at http://localhost:3000/services/storageService.ts:12:33)\n[ERROR] Error fetching master questions: {message: TypeError: Failed to fetch, details: TypeError: Failed to fetch\n    at http://localhostents/CreatorDashboard.tsx?t=1769572708202:672:18), hint: , code: } (at http://localhost:3000/services/storageService.ts:13:33)\n[WARNING] cdn.tailwindcss.com should not be used in production. To use Tailwind CSS in production, install it as a PostCSS plugin or use the Tailwind CLI: https://tailwindcss.com/docs/installation (at https://cdn.tailwindcss.com/?plugins=typography:65:26200)\n[WARNING] cdn.tailwindcss.com should not be used in production. To use Tailwind CSS in production, install it as a PostCSS plugin or use the Tailwind CLI: https://tailwindcss.com/docs/installation (at https://cdn.tailwindcss.com/?plugins=typography:65:26200)\n[WARNING] cdn.tailwindcss.com should not be used in production. To use Tailwind CSS in production, install it as a PostCSS plugin or use the Tailwind CLI: https://tailwindcss.com/docs/installation (at https://cdn.tailwindcss.com/?plugins=typography:65:26200)\n[WARNING] cdn.tailwindcss.com should not be used in production. To use Tailwind CSS in production, install it as a PostCSS plugin or use the Tailwind CLI: https://tailwindcss.com/docs/installation (at https://cdn.tailwindcss.com/?plugins=typography:65:26200)\n[WARNING] cdn.tailwindcss.com should not be used in production. To use Tailwind CSS in production, install it as a PostCSS plugin or use the Tailwind CLI: https://tailwindcss.com/docs/installation (at https://cdn.tailwindcss.com/?plugins=typography:65:26200)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/a43844e8-b011-705d-d5f8-c9d446aa6a3f/1769573919190382//tmp/test_task/result.webm",
    "created": "2026-01-28T04:07:45.272Z",
    "modified": "2026-01-28T04:18:39.372Z"
  },
  {
    "projectId": "2c95e9aa-7eab-4408-8da8-f4707b7ffbbb",
    "testId": "8ed76074-8ca3-4f25-a39d-dddcc82031ea",
    "userId": "a43844e8-b011-705d-d5f8-c9d446aa6a3f",
    "title": "TC012-Advanced Search and Filtering Interface",
    "description": "Verify rich search using multiple criteria and saved presets returns accurate and performant question lists.",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "",
    "created": "2026-01-28T04:07:45.278Z",
    "modified": "2026-01-28T04:07:45.278Z"
  },
  {
    "projectId": "2c95e9aa-7eab-4408-8da8-f4707b7ffbbb",
    "testId": "f75ee873-fdf1-4596-ae11-4c10da7d9a78",
    "userId": "a43844e8-b011-705d-d5f8-c9d446aa6a3f",
    "title": "TC013-Session Management and Presentation Tools",
    "description": "Verify full-screen presentation mode supports timers, bookmarks, annotation tools, and prompts for unsaved changes.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Presentation Completed Successfully').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError(\"Test failed: The full-screen presentation mode did not support timers, bookmarks, annotation tools, or prompt for unsaved changes as expected.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to go to the start URL. Err: Error executing action go_to_url: Page.goto: net::ERR_EMPTY_RESPONSE at http://localhost:3000/\nCall log:\n  - navigating to \"http://localhost:3000/\", waiting until \"load\"\n",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/a43844e8-b011-705d-d5f8-c9d446aa6a3f/1769573305982284//tmp/test_task/result.webm",
    "created": "2026-01-28T04:07:45.285Z",
    "modified": "2026-01-28T04:08:26.101Z"
  },
  {
    "projectId": "2c95e9aa-7eab-4408-8da8-f4707b7ffbbb",
    "testId": "a0b075d1-20e2-4709-86cc-9c5683431d46",
    "userId": "a43844e8-b011-705d-d5f8-c9d446aa6a3f",
    "title": "TC014-Interface Stability on Workflow Transitions",
    "description": "Ensure smooth, crash-free switching among input, review, generation, and preview stages with no data loss.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Unexpected Crash Detected').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError('Test case failed: The test plan requires smooth, crash-free switching among input, review, generation, and preview stages with no data loss. The presence of this message would indicate a crash or data loss occurred during stage transitions.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to go to the start URL. Err: Error executing action go_to_url: Page.goto: net::ERR_EMPTY_RESPONSE at http://localhost:3000/\nCall log:\n  - navigating to \"http://localhost:3000/\", waiting until \"load\"\n",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/a43844e8-b011-705d-d5f8-c9d446aa6a3f/1769573306249076//tmp/test_task/result.webm",
    "created": "2026-01-28T04:07:45.296Z",
    "modified": "2026-01-28T04:08:26.365Z"
  },
  {
    "projectId": "2c95e9aa-7eab-4408-8da8-f4707b7ffbbb",
    "testId": "07c31f10-ab69-4f67-8476-8864ee3992bd",
    "userId": "a43844e8-b011-705d-d5f8-c9d446aa6a3f",
    "title": "TC015-Security - Access Control and Data Encryption",
    "description": "Test role-based access control restricting unauthorized users and verify encryption of sensitive data at rest and in transit.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Access Granted: Welcome User').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Role-based access control test failed because unauthorized user was able to access data. Access should be denied and an appropriate error message should be shown.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to go to the start URL. Err: Error executing action go_to_url: Page.goto: net::ERR_EMPTY_RESPONSE at http://localhost:3000/\nCall log:\n  - navigating to \"http://localhost:3000/\", waiting until \"load\"\n",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/a43844e8-b011-705d-d5f8-c9d446aa6a3f/1769573307398385//tmp/test_task/result.webm",
    "created": "2026-01-28T04:07:45.303Z",
    "modified": "2026-01-28T04:08:27.555Z"
  },
  {
    "projectId": "2c95e9aa-7eab-4408-8da8-f4707b7ffbbb",
    "testId": "9986521a-a51b-4242-971f-414fd7c008d8",
    "userId": "a43844e8-b011-705d-d5f8-c9d446aa6a3f",
    "title": "TC016-Accessibility Compliance WCAG 2.1 AA",
    "description": "Validate application meets WCAG 2.1 Level AA using accessibility audit tools and keyboard navigation testing.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        try:\n            await expect(page.locator('text=Accessibility Perfect! No WCAG Violations Detected').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test failed: Accessibility audit detected critical WCAG 2.1 Level AA violations or keyboard navigation issues. The application does not meet the required accessibility standards.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to go to the start URL. Err: Error executing action go_to_url: Page.goto: net::ERR_EMPTY_RESPONSE at http://localhost:3000/\nCall log:\n  - navigating to \"http://localhost:3000/\", waiting until \"load\"\n",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/a43844e8-b011-705d-d5f8-c9d446aa6a3f/1769573314779223//tmp/test_task/result.webm",
    "created": "2026-01-28T04:07:45.311Z",
    "modified": "2026-01-28T04:08:34.897Z"
  }
]
